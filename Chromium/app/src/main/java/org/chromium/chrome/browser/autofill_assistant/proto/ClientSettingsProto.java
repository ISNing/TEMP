// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

/**
 * Protobuf type {@code autofill_assistant.ClientSettingsProto}
 */
public  final class ClientSettingsProto extends
    com.google.protobuf.GeneratedMessageLite<
        ClientSettingsProto, ClientSettingsProto.Builder> implements
    // @@protoc_insertion_point(message_implements:autofill_assistant.ClientSettingsProto)
    ClientSettingsProtoOrBuilder {
  private ClientSettingsProto() {
  }
  private int bitField0_;
  public static final int PERIODIC_SCRIPT_CHECK_INTERVAL_MS_FIELD_NUMBER = 1;
  private int periodicScriptCheckIntervalMs_;
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   */
  public boolean hasPeriodicScriptCheckIntervalMs() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   */
  public int getPeriodicScriptCheckIntervalMs() {
    return periodicScriptCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   */
  private void setPeriodicScriptCheckIntervalMs(int value) {
    bitField0_ |= 0x00000001;
    periodicScriptCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two periodic script precondition checks.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
   */
  private void clearPeriodicScriptCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000001);
    periodicScriptCheckIntervalMs_ = 0;
  }

  public static final int PERIODIC_ELEMENT_CHECK_INTERVAL_MS_FIELD_NUMBER = 2;
  private int periodicElementCheckIntervalMs_;
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   */
  public boolean hasPeriodicElementCheckIntervalMs() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   */
  public int getPeriodicElementCheckIntervalMs() {
    return periodicElementCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   */
  private void setPeriodicElementCheckIntervalMs(int value) {
    bitField0_ |= 0x00000002;
    periodicElementCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two element checks in the script executor.
   * </pre>
   *
   * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
   */
  private void clearPeriodicElementCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000002);
    periodicElementCheckIntervalMs_ = 0;
  }

  public static final int PERIODIC_SCRIPT_CHECK_COUNT_FIELD_NUMBER = 3;
  private int periodicScriptCheckCount_;
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   */
  public boolean hasPeriodicScriptCheckCount() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   */
  public int getPeriodicScriptCheckCount() {
    return periodicScriptCheckCount_;
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   */
  private void setPeriodicScriptCheckCount(int value) {
    bitField0_ |= 0x00000004;
    periodicScriptCheckCount_ = value;
  }
  /**
   * <pre>
   * Run that many periodic checks before giving up unless something happens to
   * wake it up, such as the user touching the screen.
   * </pre>
   *
   * <code>optional int32 periodic_script_check_count = 3;</code>
   */
  private void clearPeriodicScriptCheckCount() {
    bitField0_ = (bitField0_ & ~0x00000004);
    periodicScriptCheckCount_ = 0;
  }

  public static final int ELEMENT_POSITION_UPDATE_INTERVAL_MS_FIELD_NUMBER = 4;
  private int elementPositionUpdateIntervalMs_;
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   */
  public boolean hasElementPositionUpdateIntervalMs() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   */
  public int getElementPositionUpdateIntervalMs() {
    return elementPositionUpdateIntervalMs_;
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   */
  private void setElementPositionUpdateIntervalMs(int value) {
    bitField0_ |= 0x00000008;
    elementPositionUpdateIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time between two element position refreshes, when displaying highlighted
   * areas in prompt state.
   * </pre>
   *
   * <code>optional int32 element_position_update_interval_ms = 4;</code>
   */
  private void clearElementPositionUpdateIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000008);
    elementPositionUpdateIntervalMs_ = 0;
  }

  public static final int SHORT_WAIT_FOR_ELEMENT_DEADLINE_MS_FIELD_NUMBER = 5;
  private int shortWaitForElementDeadlineMs_;
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   */
  public boolean hasShortWaitForElementDeadlineMs() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   */
  public int getShortWaitForElementDeadlineMs() {
    return shortWaitForElementDeadlineMs_;
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   */
  private void setShortWaitForElementDeadlineMs(int value) {
    bitField0_ |= 0x00000010;
    shortWaitForElementDeadlineMs_ = value;
  }
  /**
   * <pre>
   * Maximum amount of time normal actions should implicitly wait for a selector
   * to show up.
   * </pre>
   *
   * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
   */
  private void clearShortWaitForElementDeadlineMs() {
    bitField0_ = (bitField0_ & ~0x00000010);
    shortWaitForElementDeadlineMs_ = 0;
  }

  public static final int BOX_MODEL_CHECK_INTERVAL_MS_FIELD_NUMBER = 6;
  private int boxModelCheckIntervalMs_;
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   */
  public boolean hasBoxModelCheckIntervalMs() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   */
  public int getBoxModelCheckIntervalMs() {
    return boxModelCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   */
  private void setBoxModelCheckIntervalMs(int value) {
    bitField0_ |= 0x00000020;
    boxModelCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time to wait between two checks of the box model, when waiting for an
   * element to become stable, such as before clicking.
   * </pre>
   *
   * <code>optional int32 box_model_check_interval_ms = 6;</code>
   */
  private void clearBoxModelCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000020);
    boxModelCheckIntervalMs_ = 0;
  }

  public static final int BOX_MODEL_CHECK_COUNT_FIELD_NUMBER = 7;
  private int boxModelCheckCount_;
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   */
  public boolean hasBoxModelCheckCount() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   */
  public int getBoxModelCheckCount() {
    return boxModelCheckCount_;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   */
  private void setBoxModelCheckCount(int value) {
    bitField0_ |= 0x00000040;
    boxModelCheckCount_ = value;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the element position to
   * become stable.
   * </pre>
   *
   * <code>optional int32 box_model_check_count = 7;</code>
   */
  private void clearBoxModelCheckCount() {
    bitField0_ = (bitField0_ & ~0x00000040);
    boxModelCheckCount_ = 0;
  }

  public static final int DOCUMENT_READY_CHECK_INTERVAL_MS_FIELD_NUMBER = 8;
  private int documentReadyCheckIntervalMs_;
  /**
   * <pre>
   * Time to wait between two checks of the document state, when waiting for the
   * document to become ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_interval_ms = 8;</code>
   */
  public boolean hasDocumentReadyCheckIntervalMs() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <pre>
   * Time to wait between two checks of the document state, when waiting for the
   * document to become ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_interval_ms = 8;</code>
   */
  public int getDocumentReadyCheckIntervalMs() {
    return documentReadyCheckIntervalMs_;
  }
  /**
   * <pre>
   * Time to wait between two checks of the document state, when waiting for the
   * document to become ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_interval_ms = 8;</code>
   */
  private void setDocumentReadyCheckIntervalMs(int value) {
    bitField0_ |= 0x00000080;
    documentReadyCheckIntervalMs_ = value;
  }
  /**
   * <pre>
   * Time to wait between two checks of the document state, when waiting for the
   * document to become ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_interval_ms = 8;</code>
   */
  private void clearDocumentReadyCheckIntervalMs() {
    bitField0_ = (bitField0_ & ~0x00000080);
    documentReadyCheckIntervalMs_ = 0;
  }

  public static final int DOCUMENT_READY_CHECK_COUNT_FIELD_NUMBER = 9;
  private int documentReadyCheckCount_;
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the document to become
   * ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_count = 9;</code>
   */
  public boolean hasDocumentReadyCheckCount() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the document to become
   * ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_count = 9;</code>
   */
  public int getDocumentReadyCheckCount() {
    return documentReadyCheckCount_;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the document to become
   * ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_count = 9;</code>
   */
  private void setDocumentReadyCheckCount(int value) {
    bitField0_ |= 0x00000100;
    documentReadyCheckCount_ = value;
  }
  /**
   * <pre>
   * Maximum number of checks to run while waiting for the document to become
   * ready.
   * </pre>
   *
   * <code>optional int32 document_ready_check_count = 9;</code>
   */
  private void clearDocumentReadyCheckCount() {
    bitField0_ = (bitField0_ & ~0x00000100);
    documentReadyCheckCount_ = 0;
  }

  public static final int CANCEL_DELAY_MS_FIELD_NUMBER = 12;
  private int cancelDelayMs_;
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   */
  public boolean hasCancelDelayMs() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   */
  public int getCancelDelayMs() {
    return cancelDelayMs_;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   */
  private void setCancelDelayMs(int value) {
    bitField0_ |= 0x00000200;
    cancelDelayMs_ = value;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when they tap a cancel button.
   * </pre>
   *
   * <code>optional int32 cancel_delay_ms = 12;</code>
   */
  private void clearCancelDelayMs() {
    bitField0_ = (bitField0_ & ~0x00000200);
    cancelDelayMs_ = 0;
  }

  public static final int TAP_COUNT_FIELD_NUMBER = 13;
  private int tapCount_;
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   */
  public boolean hasTapCount() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   */
  public int getTapCount() {
    return tapCount_;
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   */
  private void setTapCount(int value) {
    bitField0_ |= 0x00000400;
    tapCount_ = value;
  }
  /**
   * <pre>
   * If the user taps the overlay that many time within |tap_duration| turn the
   * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
   * are ignored.
   * </pre>
   *
   * <code>optional int32 tap_count = 13;</code>
   */
  private void clearTapCount() {
    bitField0_ = (bitField0_ & ~0x00000400);
    tapCount_ = 0;
  }

  public static final int TAP_TRACKING_DURATION_MS_FIELD_NUMBER = 14;
  private int tapTrackingDurationMs_;
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   */
  public boolean hasTapTrackingDurationMs() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   */
  public int getTapTrackingDurationMs() {
    return tapTrackingDurationMs_;
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   */
  private void setTapTrackingDurationMs(int value) {
    bitField0_ |= 0x00000800;
    tapTrackingDurationMs_ = value;
  }
  /**
   * <pre>
   * Reset the unexpected tap counter after that time.
   * </pre>
   *
   * <code>optional int32 tap_tracking_duration_ms = 14;</code>
   */
  private void clearTapTrackingDurationMs() {
    bitField0_ = (bitField0_ & ~0x00000800);
    tapTrackingDurationMs_ = 0;
  }

  public static final int TAP_SHUTDOWN_DELAY_MS_FIELD_NUMBER = 15;
  private int tapShutdownDelayMs_;
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   */
  public boolean hasTapShutdownDelayMs() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   */
  public int getTapShutdownDelayMs() {
    return tapShutdownDelayMs_;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   */
  private void setTapShutdownDelayMs(int value) {
    bitField0_ |= 0x00001000;
    tapShutdownDelayMs_ = value;
  }
  /**
   * <pre>
   * How much time to give users to tap undo when after |tap_count| unexpected
   * taps where
   * </pre>
   *
   * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
   */
  private void clearTapShutdownDelayMs() {
    bitField0_ = (bitField0_ & ~0x00001000);
    tapShutdownDelayMs_ = 0;
  }

  public static final int OVERLAY_IMAGE_FIELD_NUMBER = 16;
  private org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto overlayImage_;
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  public boolean hasOverlayImage() {
    return ((bitField0_ & 0x00002000) == 0x00002000);
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  public org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto getOverlayImage() {
    return overlayImage_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.getDefaultInstance() : overlayImage_;
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void setOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
    if (value == null) {
      throw new NullPointerException();
    }
    overlayImage_ = value;
    bitField0_ |= 0x00002000;
    }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void setOverlayImage(
      org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.Builder builderForValue) {
    overlayImage_ = builderForValue.build();
    bitField0_ |= 0x00002000;
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void mergeOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
    if (overlayImage_ != null &&
        overlayImage_ != org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.getDefaultInstance()) {
      overlayImage_ =
        org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.newBuilder(overlayImage_).mergeFrom(value).buildPartial();
    } else {
      overlayImage_ = value;
    }
    bitField0_ |= 0x00002000;
  }
  /**
   * <pre>
   * Optional image drawn on top of overlays.
   * </pre>
   *
   * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
   */
  private void clearOverlayImage() {  overlayImage_ = null;
    bitField0_ = (bitField0_ & ~0x00002000);
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeInt32(1, periodicScriptCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeInt32(2, periodicElementCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeInt32(3, periodicScriptCheckCount_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeInt32(4, elementPositionUpdateIntervalMs_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeInt32(5, shortWaitForElementDeadlineMs_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeInt32(6, boxModelCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeInt32(7, boxModelCheckCount_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeInt32(8, documentReadyCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      output.writeInt32(9, documentReadyCheckCount_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      output.writeInt32(12, cancelDelayMs_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      output.writeInt32(13, tapCount_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      output.writeInt32(14, tapTrackingDurationMs_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      output.writeInt32(15, tapShutdownDelayMs_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      output.writeMessage(16, getOverlayImage());
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(1, periodicScriptCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(2, periodicElementCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(3, periodicScriptCheckCount_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(4, elementPositionUpdateIntervalMs_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(5, shortWaitForElementDeadlineMs_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(6, boxModelCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(7, boxModelCheckCount_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(8, documentReadyCheckIntervalMs_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(9, documentReadyCheckCount_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(12, cancelDelayMs_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(13, tapCount_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(14, tapTrackingDurationMs_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(15, tapShutdownDelayMs_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(16, getOverlayImage());
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * Protobuf type {@code autofill_assistant.ClientSettingsProto}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto, Builder> implements
      // @@protoc_insertion_point(builder_implements:autofill_assistant.ClientSettingsProto)
      org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProtoOrBuilder {
    // Construct using org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     */
    public boolean hasPeriodicScriptCheckIntervalMs() {
      return instance.hasPeriodicScriptCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     */
    public int getPeriodicScriptCheckIntervalMs() {
      return instance.getPeriodicScriptCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     */
    public Builder setPeriodicScriptCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setPeriodicScriptCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two periodic script precondition checks.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_interval_ms = 1;</code>
     */
    public Builder clearPeriodicScriptCheckIntervalMs() {
      copyOnWrite();
      instance.clearPeriodicScriptCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     */
    public boolean hasPeriodicElementCheckIntervalMs() {
      return instance.hasPeriodicElementCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     */
    public int getPeriodicElementCheckIntervalMs() {
      return instance.getPeriodicElementCheckIntervalMs();
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     */
    public Builder setPeriodicElementCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setPeriodicElementCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two element checks in the script executor.
     * </pre>
     *
     * <code>optional int32 periodic_element_check_interval_ms = 2;</code>
     */
    public Builder clearPeriodicElementCheckIntervalMs() {
      copyOnWrite();
      instance.clearPeriodicElementCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     */
    public boolean hasPeriodicScriptCheckCount() {
      return instance.hasPeriodicScriptCheckCount();
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     */
    public int getPeriodicScriptCheckCount() {
      return instance.getPeriodicScriptCheckCount();
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     */
    public Builder setPeriodicScriptCheckCount(int value) {
      copyOnWrite();
      instance.setPeriodicScriptCheckCount(value);
      return this;
    }
    /**
     * <pre>
     * Run that many periodic checks before giving up unless something happens to
     * wake it up, such as the user touching the screen.
     * </pre>
     *
     * <code>optional int32 periodic_script_check_count = 3;</code>
     */
    public Builder clearPeriodicScriptCheckCount() {
      copyOnWrite();
      instance.clearPeriodicScriptCheckCount();
      return this;
    }

    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     */
    public boolean hasElementPositionUpdateIntervalMs() {
      return instance.hasElementPositionUpdateIntervalMs();
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     */
    public int getElementPositionUpdateIntervalMs() {
      return instance.getElementPositionUpdateIntervalMs();
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     */
    public Builder setElementPositionUpdateIntervalMs(int value) {
      copyOnWrite();
      instance.setElementPositionUpdateIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time between two element position refreshes, when displaying highlighted
     * areas in prompt state.
     * </pre>
     *
     * <code>optional int32 element_position_update_interval_ms = 4;</code>
     */
    public Builder clearElementPositionUpdateIntervalMs() {
      copyOnWrite();
      instance.clearElementPositionUpdateIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     */
    public boolean hasShortWaitForElementDeadlineMs() {
      return instance.hasShortWaitForElementDeadlineMs();
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     */
    public int getShortWaitForElementDeadlineMs() {
      return instance.getShortWaitForElementDeadlineMs();
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     */
    public Builder setShortWaitForElementDeadlineMs(int value) {
      copyOnWrite();
      instance.setShortWaitForElementDeadlineMs(value);
      return this;
    }
    /**
     * <pre>
     * Maximum amount of time normal actions should implicitly wait for a selector
     * to show up.
     * </pre>
     *
     * <code>optional int32 short_wait_for_element_deadline_ms = 5;</code>
     */
    public Builder clearShortWaitForElementDeadlineMs() {
      copyOnWrite();
      instance.clearShortWaitForElementDeadlineMs();
      return this;
    }

    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     */
    public boolean hasBoxModelCheckIntervalMs() {
      return instance.hasBoxModelCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     */
    public int getBoxModelCheckIntervalMs() {
      return instance.getBoxModelCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     */
    public Builder setBoxModelCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setBoxModelCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time to wait between two checks of the box model, when waiting for an
     * element to become stable, such as before clicking.
     * </pre>
     *
     * <code>optional int32 box_model_check_interval_ms = 6;</code>
     */
    public Builder clearBoxModelCheckIntervalMs() {
      copyOnWrite();
      instance.clearBoxModelCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     */
    public boolean hasBoxModelCheckCount() {
      return instance.hasBoxModelCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     */
    public int getBoxModelCheckCount() {
      return instance.getBoxModelCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     */
    public Builder setBoxModelCheckCount(int value) {
      copyOnWrite();
      instance.setBoxModelCheckCount(value);
      return this;
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the element position to
     * become stable.
     * </pre>
     *
     * <code>optional int32 box_model_check_count = 7;</code>
     */
    public Builder clearBoxModelCheckCount() {
      copyOnWrite();
      instance.clearBoxModelCheckCount();
      return this;
    }

    /**
     * <pre>
     * Time to wait between two checks of the document state, when waiting for the
     * document to become ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_interval_ms = 8;</code>
     */
    public boolean hasDocumentReadyCheckIntervalMs() {
      return instance.hasDocumentReadyCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the document state, when waiting for the
     * document to become ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_interval_ms = 8;</code>
     */
    public int getDocumentReadyCheckIntervalMs() {
      return instance.getDocumentReadyCheckIntervalMs();
    }
    /**
     * <pre>
     * Time to wait between two checks of the document state, when waiting for the
     * document to become ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_interval_ms = 8;</code>
     */
    public Builder setDocumentReadyCheckIntervalMs(int value) {
      copyOnWrite();
      instance.setDocumentReadyCheckIntervalMs(value);
      return this;
    }
    /**
     * <pre>
     * Time to wait between two checks of the document state, when waiting for the
     * document to become ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_interval_ms = 8;</code>
     */
    public Builder clearDocumentReadyCheckIntervalMs() {
      copyOnWrite();
      instance.clearDocumentReadyCheckIntervalMs();
      return this;
    }

    /**
     * <pre>
     * Maximum number of checks to run while waiting for the document to become
     * ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_count = 9;</code>
     */
    public boolean hasDocumentReadyCheckCount() {
      return instance.hasDocumentReadyCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the document to become
     * ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_count = 9;</code>
     */
    public int getDocumentReadyCheckCount() {
      return instance.getDocumentReadyCheckCount();
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the document to become
     * ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_count = 9;</code>
     */
    public Builder setDocumentReadyCheckCount(int value) {
      copyOnWrite();
      instance.setDocumentReadyCheckCount(value);
      return this;
    }
    /**
     * <pre>
     * Maximum number of checks to run while waiting for the document to become
     * ready.
     * </pre>
     *
     * <code>optional int32 document_ready_check_count = 9;</code>
     */
    public Builder clearDocumentReadyCheckCount() {
      copyOnWrite();
      instance.clearDocumentReadyCheckCount();
      return this;
    }

    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     */
    public boolean hasCancelDelayMs() {
      return instance.hasCancelDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     */
    public int getCancelDelayMs() {
      return instance.getCancelDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     */
    public Builder setCancelDelayMs(int value) {
      copyOnWrite();
      instance.setCancelDelayMs(value);
      return this;
    }
    /**
     * <pre>
     * How much time to give users to tap undo when they tap a cancel button.
     * </pre>
     *
     * <code>optional int32 cancel_delay_ms = 12;</code>
     */
    public Builder clearCancelDelayMs() {
      copyOnWrite();
      instance.clearCancelDelayMs();
      return this;
    }

    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     */
    public boolean hasTapCount() {
      return instance.hasTapCount();
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     */
    public int getTapCount() {
      return instance.getTapCount();
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     */
    public Builder setTapCount(int value) {
      copyOnWrite();
      instance.setTapCount(value);
      return this;
    }
    /**
     * <pre>
     * If the user taps the overlay that many time within |tap_duration| turn the
     * UI off and give them |tap_shutdown_delay| to undo. If 0, unexpected taps
     * are ignored.
     * </pre>
     *
     * <code>optional int32 tap_count = 13;</code>
     */
    public Builder clearTapCount() {
      copyOnWrite();
      instance.clearTapCount();
      return this;
    }

    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     */
    public boolean hasTapTrackingDurationMs() {
      return instance.hasTapTrackingDurationMs();
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     */
    public int getTapTrackingDurationMs() {
      return instance.getTapTrackingDurationMs();
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     */
    public Builder setTapTrackingDurationMs(int value) {
      copyOnWrite();
      instance.setTapTrackingDurationMs(value);
      return this;
    }
    /**
     * <pre>
     * Reset the unexpected tap counter after that time.
     * </pre>
     *
     * <code>optional int32 tap_tracking_duration_ms = 14;</code>
     */
    public Builder clearTapTrackingDurationMs() {
      copyOnWrite();
      instance.clearTapTrackingDurationMs();
      return this;
    }

    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     */
    public boolean hasTapShutdownDelayMs() {
      return instance.hasTapShutdownDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     */
    public int getTapShutdownDelayMs() {
      return instance.getTapShutdownDelayMs();
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     */
    public Builder setTapShutdownDelayMs(int value) {
      copyOnWrite();
      instance.setTapShutdownDelayMs(value);
      return this;
    }
    /**
     * <pre>
     * How much time to give users to tap undo when after |tap_count| unexpected
     * taps where
     * </pre>
     *
     * <code>optional int32 tap_shutdown_delay_ms = 15;</code>
     */
    public Builder clearTapShutdownDelayMs() {
      copyOnWrite();
      instance.clearTapShutdownDelayMs();
      return this;
    }

    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public boolean hasOverlayImage() {
      return instance.hasOverlayImage();
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto getOverlayImage() {
      return instance.getOverlayImage();
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder setOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
      copyOnWrite();
      instance.setOverlayImage(value);
      return this;
      }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder setOverlayImage(
        org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.Builder builderForValue) {
      copyOnWrite();
      instance.setOverlayImage(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder mergeOverlayImage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto value) {
      copyOnWrite();
      instance.mergeOverlayImage(value);
      return this;
    }
    /**
     * <pre>
     * Optional image drawn on top of overlays.
     * </pre>
     *
     * <code>optional .autofill_assistant.OverlayImageProto overlay_image = 16;</code>
     */
    public Builder clearOverlayImage() {  copyOnWrite();
      instance.clearOverlayImage();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:autofill_assistant.ClientSettingsProto)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto other = (org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto) arg1;
        periodicScriptCheckIntervalMs_ = visitor.visitInt(
            hasPeriodicScriptCheckIntervalMs(), periodicScriptCheckIntervalMs_,
            other.hasPeriodicScriptCheckIntervalMs(), other.periodicScriptCheckIntervalMs_);
        periodicElementCheckIntervalMs_ = visitor.visitInt(
            hasPeriodicElementCheckIntervalMs(), periodicElementCheckIntervalMs_,
            other.hasPeriodicElementCheckIntervalMs(), other.periodicElementCheckIntervalMs_);
        periodicScriptCheckCount_ = visitor.visitInt(
            hasPeriodicScriptCheckCount(), periodicScriptCheckCount_,
            other.hasPeriodicScriptCheckCount(), other.periodicScriptCheckCount_);
        elementPositionUpdateIntervalMs_ = visitor.visitInt(
            hasElementPositionUpdateIntervalMs(), elementPositionUpdateIntervalMs_,
            other.hasElementPositionUpdateIntervalMs(), other.elementPositionUpdateIntervalMs_);
        shortWaitForElementDeadlineMs_ = visitor.visitInt(
            hasShortWaitForElementDeadlineMs(), shortWaitForElementDeadlineMs_,
            other.hasShortWaitForElementDeadlineMs(), other.shortWaitForElementDeadlineMs_);
        boxModelCheckIntervalMs_ = visitor.visitInt(
            hasBoxModelCheckIntervalMs(), boxModelCheckIntervalMs_,
            other.hasBoxModelCheckIntervalMs(), other.boxModelCheckIntervalMs_);
        boxModelCheckCount_ = visitor.visitInt(
            hasBoxModelCheckCount(), boxModelCheckCount_,
            other.hasBoxModelCheckCount(), other.boxModelCheckCount_);
        documentReadyCheckIntervalMs_ = visitor.visitInt(
            hasDocumentReadyCheckIntervalMs(), documentReadyCheckIntervalMs_,
            other.hasDocumentReadyCheckIntervalMs(), other.documentReadyCheckIntervalMs_);
        documentReadyCheckCount_ = visitor.visitInt(
            hasDocumentReadyCheckCount(), documentReadyCheckCount_,
            other.hasDocumentReadyCheckCount(), other.documentReadyCheckCount_);
        cancelDelayMs_ = visitor.visitInt(
            hasCancelDelayMs(), cancelDelayMs_,
            other.hasCancelDelayMs(), other.cancelDelayMs_);
        tapCount_ = visitor.visitInt(
            hasTapCount(), tapCount_,
            other.hasTapCount(), other.tapCount_);
        tapTrackingDurationMs_ = visitor.visitInt(
            hasTapTrackingDurationMs(), tapTrackingDurationMs_,
            other.hasTapTrackingDurationMs(), other.tapTrackingDurationMs_);
        tapShutdownDelayMs_ = visitor.visitInt(
            hasTapShutdownDelayMs(), tapShutdownDelayMs_,
            other.hasTapShutdownDelayMs(), other.tapShutdownDelayMs_);
        overlayImage_ = visitor.visitMessage(overlayImage_, other.overlayImage_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 8: {
                bitField0_ |= 0x00000001;
                periodicScriptCheckIntervalMs_ = input.readInt32();
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                periodicElementCheckIntervalMs_ = input.readInt32();
                break;
              }
              case 24: {
                bitField0_ |= 0x00000004;
                periodicScriptCheckCount_ = input.readInt32();
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                elementPositionUpdateIntervalMs_ = input.readInt32();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000010;
                shortWaitForElementDeadlineMs_ = input.readInt32();
                break;
              }
              case 48: {
                bitField0_ |= 0x00000020;
                boxModelCheckIntervalMs_ = input.readInt32();
                break;
              }
              case 56: {
                bitField0_ |= 0x00000040;
                boxModelCheckCount_ = input.readInt32();
                break;
              }
              case 64: {
                bitField0_ |= 0x00000080;
                documentReadyCheckIntervalMs_ = input.readInt32();
                break;
              }
              case 72: {
                bitField0_ |= 0x00000100;
                documentReadyCheckCount_ = input.readInt32();
                break;
              }
              case 96: {
                bitField0_ |= 0x00000200;
                cancelDelayMs_ = input.readInt32();
                break;
              }
              case 104: {
                bitField0_ |= 0x00000400;
                tapCount_ = input.readInt32();
                break;
              }
              case 112: {
                bitField0_ |= 0x00000800;
                tapTrackingDurationMs_ = input.readInt32();
                break;
              }
              case 120: {
                bitField0_ |= 0x00001000;
                tapShutdownDelayMs_ = input.readInt32();
                break;
              }
              case 130: {
                org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.Builder subBuilder = null;
                if (((bitField0_ & 0x00002000) == 0x00002000)) {
                  subBuilder = overlayImage_.toBuilder();
                }
                overlayImage_ = input.readMessage(org.chromium.chrome.browser.autofill_assistant.proto.OverlayImageProto.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(overlayImage_);
                  overlayImage_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00002000;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto)
  private static final org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new ClientSettingsProto();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.ClientSettingsProto getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<ClientSettingsProto> PARSER;

  public static com.google.protobuf.Parser<ClientSettingsProto> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

